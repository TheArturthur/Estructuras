; Macros:
swap: MACRO(ra,rb)
	or r1,ra,ra
	or ra,rb,rb
	or rb,r1,r1
ENDMACRO
PUSH: MACRO (reg)
	subu r30, r30, 4
	st reg, r30, 0
ENDMACRO
POP: MACRO (reg)
	ld reg, r30, 0
	addu r30, r30, 4
ENDMACRO
LEA: MACRO(reg, dato)
	or reg, r0, low(dato)
	or.u reg, reg, high(dato)
ENDMACRO

;Datos para pruebas:
org 0
nF: data 100

or	r30, r0, 2000
or r31, r30, r30

addu	r10, r0, 3
PUSH (r10)

nFiltrados:						;nFiltrados (oper)
	PUSH	(r1)
	or 		r29, r0, r0		; r29 = 0 (inicializar)
	ld		r02, r30, 4	; r2 <- oper
	ld		r04, r0, r0		; r4 <- nF (nF esta en la dir 0)
	cmp		r05, r02, r0

	;Si oper >= 0:
	bb1		ge, r05, OPER_POS

	;Si oper < 0:
	subu	r04, r04, 1
	cmp		r05, r04, r0

	;Si nF < 0:
	bb1		lt, r5, NF_NEG
	br		FIN_nF

OPER_POS:
	or 		r04, r02, r0; r4 <- oper
	br		FIN_nF

NF_NEG:
	and		r04, r0, r0; r4 <- nF
	br		FIN_nF

FIN_nF:
	or 		r29, r04, r0; r29 <- r4 (res)
	POP		(r1)
	jmp		(r1)

Comp:
	PUSH	(r1)
	or		r02, r0, r0 	; Dif = 0
	or		r29, r0, r0		; r29 = 0
	ld		r04, r30, 4		; dir Im1
	ld		r06, r30, 8		; dir Im2
	ld		r08, r04, 4		; r8 <- N1
	ld		r10, r06, 4		; r10 <- N2
	ld		r11, r04, r0	; r11 <- M1
	ld		r12, r06, r0	; r12 <- M2

	mulu	r08, r11, r08	; r8 <- M1*N1
	mulu	r10, r12, r10	; r10 <- M2*N2
	cmp		r03, r08, r10

; Si tienen distinto tamaño => FIN
	bb1		ne, r03, FIN_cmp

; Si los tamaños son iguales:
COMPARA:
	or		r11, r04, 8		; r11 <-Dato1_Im1
	or		r12, r06, 8		; r12 <-Dato1_Im2
	sub		r13, r11, r12
	muls	r13, r13, r13
	add		r02, r02, r13
	or		r11, r11, 4		; r11 <- r11+4 (Acutaliza puntero)
	or		r12, r12, 4		; r12 <- r12+4 (Actualiza puntero)
	cmp		r03, r08, r0
	bb1		gt, r03, COMPARA

FIN_cmp:
	divu	r02, r02, r8	; r2 (Dif) = Dif / M*N
	or		r29, r02, r0	; r29 <- Dif
	POP		(r1)
	jmp		(r1)


ActualizaFiltro:			;ActualizaFiltro (MFiltro, ModFiltro)
	PUSH	(r1)
	ld		r02, r30, 4		; ModFiltro
	ld		r04, r30, 8		; MFiltro
	ld		r06, r02, 0		; r6 <- numerador
	ld		r08, r02, 4		; r8 <- denominador
	muls	r10, r06, r08	; r10 = numerador * denominador
	cmp		r03, r10, r0
	;Si numerador * denominador = 0, uno de los dos (o ambos) es nulo:
	bb1		eq, r03, FIN_ACTF
	;Si no es cero, ninguno es nulo:
	or		r09, r0, r0		; Contador
	or		r11, r02, r0	; Puntero

BUC_ACTF:
	ld		r12, r11, 0		; r12 <- dato Matriz
	muls	r13, r12, r6	; r13 <- dato * numerador
	divs	r14, r13, r8	; r14 <- dato * numerador / denominador
	st		r14, r11, 0		; r14 <- puntero (devuelve dato)
	addu	r09, r09, 1		; contador = contador + 1
	addu	r11, r11, 4		; actualiza puntero
	cmp		r05, r09, 8
	; Si faltan datos en la matriz por actualizar, repite con el siguiente:
	bb1		le, r05, BUC_ACTF
	; Si no faltan datos, termina:

FIN_ACTF:
	POP		(r1)
	jmp		(r1)


FiltRec:
	jmp		(r1)

SubMatriz: 						; SubMatriz (Img, SubImg, i, j)
	PUSH	(r1)
	;Carga de datos en registros:
	ld		r02, r30, 8		; r2 <- i
	ld		r04, r30, 4		; r4 <- j
	ld		r06, r30, 16	; r6 <- Img (dir)
	ld		r08, r30, 12	; r8 <- SubImg (dir)
	ld		r10, r08, 0		; r10 <- M
	ld		r11, r08, 4		; r11 <- N
	mulu	r15, r02, r11	; r15 <- i * N
	addu	r15, r15, r04	; r15 <- i * N + j
	addu	r16, r0, r0		; r16 <- 0 (contador para elementos de SubImg que quedan por copiar)
	;Operaciones para comprobaciones de i y de j:
	mulu	r12, r02, r04	; r12 <- i*j
	subu	r13, r10, 1		; r13 <- M-1
	subu	r14, r11, 1		; r14 <- N-1
	cmp		r03, r12, 0
	;Si i*j=0 => i=0 y/o j=0 => elemento en borde
	bb1		eq, r03, SM_EXTR
	;Si no, puede seguir en borde si i=M-1 y/o j=N-1:
	cmp		r05, r13, r02
	;Si i=M-1 => elemento en borde:
	bb1		eq, r05, SM_EXTR
	;Si no, comprobamos j=N-1:
	cmp		r07, r14, r04
	;Si j=N-1 => elemento en borde:
	bb1		eq, r07, SM_EXTR

SM_N_EXTR:
	addu	r17, r06, 8		; r17 <- r6 + 8
	ld		r18, r17, r16	;	r18 <- r17 + r16 (dato + despl)
	addu	r16, r16, 1		; r16 <- r16 + 1 (actualizar contador)
	cmp		r03, r16, 8
	;Si r16 <= 8, siguiente iteracion:
	bb1		le, r03, SM_N_EXTR
	;Si r16 > 8, FIN_SM
	br		FIN_SM

SM_EXTR:							; Bucle para copiar elemento en SubImg (dato en borde)
	st		r15, r08, r16		; r15 -> M(r8+r16), siendo r16 el despl junto a contador
	addu	r16, r16, 1		; r16 <- r16 + 1 (contador de elementos para salir del bucle)
	cmp		r03, r16, 8
	;Si r16 <= 8, quedan elementos por copiar, salta a siguiente iteracion:
	bb1		le, r03, SM_EXTR
	;Si r16 > 8, no quedan elementos, salta a FIN:
	br		FIN_SM

FIN_SM:
	POP		(r1)
	jmp		(r1)

ValorPixel:
	jmp		(r1)

FilPixel:
	jmp		(r1)

Filtro:
	jmp		(r1)
